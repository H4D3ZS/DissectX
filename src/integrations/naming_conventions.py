"""
Naming Convention Adapters for DissectX

This module provides unified naming convention adapters for converting
between DissectX and external tool naming conventions (Ghidra, IDA Pro, Radare2).

The adapters ensure consistent naming across different reverse engineering tools
and provide bidirectional conversion capabilities.
"""
from typing import Dict, Optional, Any
from enum import Enum
from dataclasses import dataclass


class ToolType(Enum):
    """Supported reverse engineering tools"""
    DISSECTX = "dissectx"
    GHIDRA = "ghidra"
    IDA = "ida"
    RADARE2 = "radare2"


class EntityType(Enum):
    """Types of entities that can be named"""
    FUNCTION = "function"
    LABEL = "label"
    DATA = "data"
    STRING = "string"
    IMPORT = "import"
    EXPORT = "export"
    STRUCT = "struct"
    ENUM = "enum"
    VARIABLE = "variable"


@dataclass
class NamedEntity:
    """
    Represents a named entity in a binary.
    
    Attributes:
        address: Memory address of the entity
        name: Current name of the entity
        entity_type: Type of entity (function, label, data, etc.)
        original_name: Original name before any conversion (optional)
        metadata: Additional metadata about the entity
    """
    address: int
    name: str
    entity_type: EntityType
    original_name: Optional[str] = None
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}
        if self.original_name is None:
            self.original_name = self.name


class NamingConventionAdapter:
    """
    Base class for naming convention adapters.
    
    Provides methods to convert names between DissectX and external tool formats.
    """
    
    def __init__(self, tool_type: ToolType):
        """
        Initialize naming convention adapter.
        
        Args:
            tool_type: The tool this adapter is for
        """
        self.tool_type = tool_type
    
    def to_tool_name(self, entity: NamedEntity) -> str:
        """
        Convert a DissectX name to the tool's naming convention.
        
        Args:
            entity: Named entity to convert
            
        Returns:
            Name following the tool's convention
        """
        raise NotImplementedError("Subclasses must implement to_tool_name")
    
    def from_tool_name(self, name: str, address: int, 
                       entity_type: EntityType) -> NamedEntity:
        """
        Convert a tool name to DissectX format.
        
        Args:
            name: Name from the external tool
            address: Entity address
            entity_type: Type of entity
            
        Returns:
            NamedEntity with normalized name
        """
        raise NotImplementedError("Subclasses must implement from_tool_name")
    
    def is_auto_generated_name(self, name: str, entity_type: EntityType) -> bool:
        """
        Check if a name is auto-generated by the tool.
        
        Args:
            name: Name to check
            entity_type: Type of entity
            
        Returns:
            True if name is auto-generated, False if user-defined
        """
        raise NotImplementedError("Subclasses must implement is_auto_generated_name")
    
    def sanitize_name(self, name: str) -> str:
        """
        Sanitize a name to be compatible with the tool.
        
        Args:
            name: Name to sanitize
            
        Returns:
            Sanitized name
        """
        raise NotImplementedError("Subclasses must implement sanitize_name")


class GhidraNamingAdapter(NamingConventionAdapter):
    """
    Naming convention adapter for Ghidra.
    
    Ghidra naming conventions:
    - Functions: FUN_<address> (auto), user names preserved
    - Labels: LAB_<address> (auto)
    - Data: DAT_<address> (auto)
    - Strings: s_<content>_<address> (auto)
    - Imports: <name> (preserved)
    """
    
    def __init__(self):
        super().__init__(ToolType.GHIDRA)
    
    def to_tool_name(self, entity: NamedEntity) -> str:
        """Convert DissectX name to Ghidra convention"""
        name = entity.name
        address = entity.address
        entity_type = entity.entity_type
        
        # If name is meaningful (not auto-generated), sanitize and use it
        if name and not self._is_dissectx_auto_name(name):
            return self.sanitize_name(name)
        
        # Generate Ghidra-style auto name
        if entity_type == EntityType.FUNCTION:
            return f'FUN_{address:08x}'
        elif entity_type == EntityType.LABEL:
            return f'LAB_{address:08x}'
        elif entity_type == EntityType.DATA:
            return f'DAT_{address:08x}'
        elif entity_type == EntityType.STRING:
            # Try to include content preview
            if entity.metadata and 'content' in entity.metadata:
                content = entity.metadata['content'][:20].replace(' ', '_')
                safe_content = ''.join(c if c.isalnum() or c == '_' else '_' for c in content)
                return f's_{safe_content}_{address:08x}'
            return f's_{address:08x}'
        elif entity_type == EntityType.IMPORT:
            return self.sanitize_name(name) if name else f'IMP_{address:08x}'
        else:
            return f'UNK_{address:08x}'
    
    def from_tool_name(self, name: str, address: int, 
                       entity_type: EntityType) -> NamedEntity:
        """Convert Ghidra name to DissectX format"""
        # Preserve the original name
        return NamedEntity(
            address=address,
            name=name,
            entity_type=entity_type,
            original_name=name,
            metadata={'source_tool': 'ghidra'}
        )
    
    def is_auto_generated_name(self, name: str, entity_type: EntityType) -> bool:
        """Check if name is Ghidra auto-generated"""
        if not name:
            return True
        
        # Check for Ghidra auto-generated patterns
        auto_prefixes = ['FUN_', 'LAB_', 'DAT_', 's_', 'UNK_']
        return any(name.startswith(prefix) for prefix in auto_prefixes)
    
    def sanitize_name(self, name: str) -> str:
        """Sanitize name for Ghidra (alphanumeric and underscore)"""
        if not name:
            return 'unnamed'
        
        # Replace invalid characters with underscore
        sanitized = ''.join(c if c.isalnum() or c == '_' else '_' for c in name)
        
        # Ensure name doesn't start with a digit
        if sanitized and sanitized[0].isdigit():
            sanitized = '_' + sanitized
        
        return sanitized or 'unnamed'
    
    def _is_dissectx_auto_name(self, name: str) -> bool:
        """Check if name is DissectX auto-generated"""
        auto_prefixes = ['sub_', 'loc_', 'data_', 'str_', 'func_']
        return any(name.startswith(prefix) for prefix in auto_prefixes)


class IDANamingAdapter(NamingConventionAdapter):
    """
    Naming convention adapter for IDA Pro.
    
    IDA Pro naming conventions:
    - Functions: sub_<address> (auto), user names preserved
    - Labels: loc_<address> (auto), locret_<address> (return)
    - Data: byte_<address>, word_<address>, dword_<address>, qword_<address> (auto)
    - Strings: a<Content>_<address> (auto, e.g., aHelloWorld_401000)
    - Imports: __imp_<name> (auto)
    """
    
    def __init__(self):
        super().__init__(ToolType.IDA)
    
    def to_tool_name(self, entity: NamedEntity) -> str:
        """Convert DissectX name to IDA Pro convention"""
        name = entity.name
        address = entity.address
        entity_type = entity.entity_type
        
        # Special handling for imports - always add __imp_ prefix
        if entity_type == EntityType.IMPORT:
            sanitized = self.sanitize_name(name) if name else f'{address:X}'
            return f'__imp_{sanitized}'
        
        # If name is meaningful (not auto-generated), sanitize and use it
        if name and not self._is_dissectx_auto_name(name):
            return self.sanitize_name(name)
        
        # Generate IDA-style auto name
        if entity_type == EntityType.FUNCTION:
            return f'sub_{address:X}'
        elif entity_type == EntityType.LABEL:
            return f'loc_{address:X}'
        elif entity_type == EntityType.DATA:
            # Could be more specific based on size
            size = entity.metadata.get('size', 1) if entity.metadata else 1
            if size == 1:
                return f'byte_{address:X}'
            elif size == 2:
                return f'word_{address:X}'
            elif size == 4:
                return f'dword_{address:X}'
            elif size == 8:
                return f'qword_{address:X}'
            else:
                return f'unk_{address:X}'
        elif entity_type == EntityType.STRING:
            # IDA uses 'a' prefix for ASCII strings
            if entity.metadata and 'content' in entity.metadata:
                content = entity.metadata['content'][:15]
                safe_content = ''.join(c for c in content if c.isalnum())
                if safe_content:
                    return f'a{safe_content}_{address:X}'
            return f'asc_{address:X}'
        else:
            return f'unk_{address:X}'
    
    def from_tool_name(self, name: str, address: int, 
                       entity_type: EntityType) -> NamedEntity:
        """Convert IDA Pro name to DissectX format"""
        # Preserve the original name
        return NamedEntity(
            address=address,
            name=name,
            entity_type=entity_type,
            original_name=name,
            metadata={'source_tool': 'ida'}
        )
    
    def is_auto_generated_name(self, name: str, entity_type: EntityType) -> bool:
        """Check if name is IDA Pro auto-generated"""
        if not name:
            return True
        
        # Check for IDA auto-generated patterns
        auto_prefixes = ['sub_', 'loc_', 'locret_', 'byte_', 'word_', 
                        'dword_', 'qword_', 'unk_', 'asc_', '__imp_']
        
        # Also check for 'a' prefix followed by content (string names)
        if name.startswith('a') and len(name) > 1 and name[1].isupper():
            return True
        
        return any(name.startswith(prefix) for prefix in auto_prefixes)
    
    def sanitize_name(self, name: str) -> str:
        """Sanitize name for IDA Pro (alphanumeric and underscore only)"""
        if not name:
            return 'unnamed'
        
        # Replace invalid characters with underscore
        sanitized = ''.join(c if c.isalnum() or c == '_' else '_' for c in name)
        
        # IDA names cannot start with a digit
        if sanitized and sanitized[0].isdigit():
            sanitized = '_' + sanitized
        
        return sanitized or 'unnamed'
    
    def _is_dissectx_auto_name(self, name: str) -> bool:
        """Check if name is DissectX auto-generated"""
        auto_prefixes = ['FUN_', 'LAB_', 'DAT_', 'func_', 'data_', 'str_']
        return any(name.startswith(prefix) for prefix in auto_prefixes)


class Radare2NamingAdapter(NamingConventionAdapter):
    """
    Naming convention adapter for Radare2.
    
    Radare2 naming conventions:
    - Functions: fcn.<address> (auto), sym.<name> (symbol)
    - Flags: flag.<address> (auto)
    - Strings: str.<content> (auto)
    - Imports: sym.imp.<name> (auto)
    - Symbols: sym.<name> (preserved)
    """
    
    def __init__(self):
        super().__init__(ToolType.RADARE2)
    
    def to_tool_name(self, entity: NamedEntity) -> str:
        """Convert DissectX name to Radare2 convention"""
        name = entity.name
        address = entity.address
        entity_type = entity.entity_type
        
        # If name is meaningful (not auto-generated), use sym. prefix
        if name and not self._is_dissectx_auto_name(name):
            sanitized = self.sanitize_name(name)
            
            if entity_type == EntityType.FUNCTION:
                if not sanitized.startswith('fcn.') and not sanitized.startswith('sym.'):
                    return f'sym.{sanitized}'
                return sanitized
            elif entity_type == EntityType.IMPORT:
                if not sanitized.startswith('sym.imp.'):
                    return f'sym.imp.{sanitized}'
                return sanitized
            elif entity_type == EntityType.STRING:
                if not sanitized.startswith('str.'):
                    return f'str.{sanitized}'
                return sanitized
            else:
                return sanitized
        
        # Generate Radare2-style auto name
        if entity_type == EntityType.FUNCTION:
            return f'fcn.{address:08x}'
        elif entity_type == EntityType.LABEL:
            return f'flag.{address:08x}'
        elif entity_type == EntityType.STRING:
            if entity.metadata and 'content' in entity.metadata:
                content = entity.metadata['content'][:20].replace(' ', '_')
                safe_content = ''.join(c if c.isalnum() or c in '._' else '_' for c in content)
                return f'str.{safe_content}'
            return f'str.{address:08x}'
        elif entity_type == EntityType.IMPORT:
            return f'sym.imp.{address:08x}'
        else:
            return f'unk.{address:08x}'
    
    def from_tool_name(self, name: str, address: int, 
                       entity_type: EntityType) -> NamedEntity:
        """Convert Radare2 name to DissectX format"""
        # Preserve the original name
        return NamedEntity(
            address=address,
            name=name,
            entity_type=entity_type,
            original_name=name,
            metadata={'source_tool': 'radare2'}
        )
    
    def is_auto_generated_name(self, name: str, entity_type: EntityType) -> bool:
        """Check if name is Radare2 auto-generated"""
        if not name:
            return True
        
        # Check for Radare2 auto-generated patterns
        auto_patterns = ['fcn.', 'flag.', 'str.', 'sym.imp.', 'unk.']
        
        # Check if it's just a prefix with hex address
        for pattern in auto_patterns:
            if name.startswith(pattern):
                suffix = name[len(pattern):]
                # Check if suffix is a hex address
                try:
                    int(suffix, 16)
                    return True
                except ValueError:
                    pass
        
        return False
    
    def sanitize_name(self, name: str) -> str:
        """Sanitize name for Radare2 (alphanumeric, underscore, and dot)"""
        if not name:
            return 'unnamed'
        
        # Replace invalid characters with underscore
        sanitized = ''.join(c if c.isalnum() or c in '._' else '_' for c in name)
        
        return sanitized or 'unnamed'
    
    def _is_dissectx_auto_name(self, name: str) -> bool:
        """Check if name is DissectX auto-generated"""
        auto_prefixes = ['sub_', 'loc_', 'FUN_', 'LAB_', 'DAT_', 'func_', 'data_']
        return any(name.startswith(prefix) for prefix in auto_prefixes)


class DissectXNamingAdapter(NamingConventionAdapter):
    """
    Naming convention adapter for DissectX native format.
    
    DissectX naming conventions:
    - Functions: func_<address> (auto), user names preserved
    - Labels: loc_<address> (auto)
    - Data: data_<address> (auto)
    - Strings: str_<address> (auto)
    """
    
    def __init__(self):
        super().__init__(ToolType.DISSECTX)
    
    def to_tool_name(self, entity: NamedEntity) -> str:
        """Convert to DissectX convention (usually just sanitize)"""
        name = entity.name
        address = entity.address
        entity_type = entity.entity_type
        
        # If name is meaningful, sanitize and use it
        if name and not self.is_auto_generated_name(name, entity_type):
            return self.sanitize_name(name)
        
        # Generate DissectX-style auto name
        if entity_type == EntityType.FUNCTION:
            return f'func_{address:08x}'
        elif entity_type == EntityType.LABEL:
            return f'loc_{address:08x}'
        elif entity_type == EntityType.DATA:
            return f'data_{address:08x}'
        elif entity_type == EntityType.STRING:
            return f'str_{address:08x}'
        elif entity_type == EntityType.IMPORT:
            return self.sanitize_name(name) if name else f'imp_{address:08x}'
        else:
            return f'unk_{address:08x}'
    
    def from_tool_name(self, name: str, address: int, 
                       entity_type: EntityType) -> NamedEntity:
        """Convert external name to DissectX format"""
        return NamedEntity(
            address=address,
            name=name,
            entity_type=entity_type,
            original_name=name
        )
    
    def is_auto_generated_name(self, name: str, entity_type: EntityType) -> bool:
        """Check if name is DissectX auto-generated"""
        if not name:
            return True
        
        auto_prefixes = ['func_', 'loc_', 'data_', 'str_', 'imp_', 'unk_']
        return any(name.startswith(prefix) for prefix in auto_prefixes)
    
    def sanitize_name(self, name: str) -> str:
        """Sanitize name for DissectX (alphanumeric and underscore)"""
        if not name:
            return 'unnamed'
        
        # Replace invalid characters with underscore
        sanitized = ''.join(c if c.isalnum() or c == '_' else '_' for c in name)
        
        return sanitized or 'unnamed'


class NamingConventionConverter:
    """
    Converter for translating names between different tool conventions.
    
    Provides high-level interface for converting names between DissectX
    and external tools (Ghidra, IDA Pro, Radare2).
    """
    
    def __init__(self):
        """Initialize converter with all adapters"""
        self.adapters = {
            ToolType.DISSECTX: DissectXNamingAdapter(),
            ToolType.GHIDRA: GhidraNamingAdapter(),
            ToolType.IDA: IDANamingAdapter(),
            ToolType.RADARE2: Radare2NamingAdapter()
        }
    
    def convert(self, entity: NamedEntity, 
                from_tool: ToolType, 
                to_tool: ToolType) -> str:
        """
        Convert a name from one tool's convention to another.
        
        Args:
            entity: Named entity to convert
            from_tool: Source tool type
            to_tool: Target tool type
            
        Returns:
            Name in target tool's convention
        """
        if from_tool == to_tool:
            return entity.name
        
        # Get adapters
        from_adapter = self.adapters.get(from_tool)
        to_adapter = self.adapters.get(to_tool)
        
        if not from_adapter or not to_adapter:
            raise ValueError(f"Unsupported tool type: {from_tool} or {to_tool}")
        
        # If converting from external tool to DissectX, normalize first
        if from_tool != ToolType.DISSECTX:
            entity = from_adapter.from_tool_name(
                entity.name, entity.address, entity.entity_type
            )
        
        # Convert to target tool
        return to_adapter.to_tool_name(entity)
    
    def get_adapter(self, tool_type: ToolType) -> NamingConventionAdapter:
        """
        Get the naming adapter for a specific tool.
        
        Args:
            tool_type: Tool to get adapter for
            
        Returns:
            Naming convention adapter
        """
        adapter = self.adapters.get(tool_type)
        if not adapter:
            raise ValueError(f"Unsupported tool type: {tool_type}")
        return adapter
    
    def is_meaningful_name(self, name: str, entity_type: EntityType,
                          tool_type: ToolType) -> bool:
        """
        Check if a name is meaningful (user-defined) or auto-generated.
        
        Args:
            name: Name to check
            entity_type: Type of entity
            tool_type: Tool that generated the name
            
        Returns:
            True if name is meaningful, False if auto-generated
        """
        adapter = self.get_adapter(tool_type)
        return not adapter.is_auto_generated_name(name, entity_type)
    
    def batch_convert(self, entities: list[NamedEntity],
                     from_tool: ToolType,
                     to_tool: ToolType) -> Dict[int, str]:
        """
        Convert multiple entities at once.
        
        Args:
            entities: List of named entities to convert
            from_tool: Source tool type
            to_tool: Target tool type
            
        Returns:
            Dictionary mapping addresses to converted names
        """
        result = {}
        for entity in entities:
            converted_name = self.convert(entity, from_tool, to_tool)
            result[entity.address] = converted_name
        return result
