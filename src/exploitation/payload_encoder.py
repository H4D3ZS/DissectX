import random
from typing import List, Tuple

class PayloadEncoder:
    """
    Encodes shellcode to avoid bad characters and evade detection.
    """

    def __init__(self):
        pass

    def encode_xor(self, shellcode: bytes, bad_chars: bytes = b'') -> Tuple[bytes, int]:
        """
        Encode shellcode using XOR with a random key that avoids bad chars.
        
        Args:
            shellcode: Raw shellcode bytes
            bad_chars: Bytes to avoid in the encoded payload
            
        Returns:
            Tuple of (encoded_payload, key)
        """
        # Find a valid key
        key = 0
        encoded = b''
        
        # Try random keys until one works (simple approach)
        for _ in range(255):
            candidate_key = random.randint(1, 255)
            
            # Check if key itself is bad
            if bytes([candidate_key]) in bad_chars:
                continue
                
            # Check if encoded payload has bad chars
            temp_encoded = bytearray()
            valid = True
            for b in shellcode:
                enc_byte = b ^ candidate_key
                if bytes([enc_byte]) in bad_chars:
                    valid = False
                    break
                temp_encoded.append(enc_byte)
            
            if valid:
                key = candidate_key
                encoded = bytes(temp_encoded)
                break
        
        if key == 0:
            raise ValueError("Could not find a valid XOR key to avoid bad characters")
            
        # Add decoder stub (x64 example)
        # This is a very simple stub. In a real scenario, we'd need a polymorphic decoder.
        # For now, we return the encoded payload and let the user handle the decoder 
        # or we append a static stub (which might have bad chars itself, limiting this).
        
        # Simple x64 XOR decoder stub (assuming payload follows immediately)
        # jmp get_addr
        # decoder:
        # pop rsi (address of payload)
        # mov rcx, len
        # loop:
        # xor byte ptr [rsi], key
        # inc rsi
        # loop loop
        # jmp payload
        
        return encoded, key

    def generate_decoder_stub(self, key: int, length: int, arch: str = 'x64') -> bytes:
        """
        Generate a decoder stub for the encoded payload.
        
        Args:
            key: XOR key
            length: Length of encoded payload
            arch: Architecture
            
        Returns:
            Decoder stub bytes
        """
        if arch == 'x64':
            # Simple x64 XOR decoder (not optimized for bad chars)
            # 48 31 c9          xor rcx, rcx
            # 48 81 c1 len      add rcx, length
            # 48 8d 35 0a 00 00 00 lea rsi, [rip + 10] ; Address of encoded data
            # loop_start:
            # 80 36 key         xor byte ptr [rsi], key
            # 48 ff c6          inc rsi
            # 48 ff c9          dec rcx
            # 75 f6             jnz loop_start
            
            # This is hard to make generic without bad chars.
            # For this MVP, we'll return a placeholder or simple stub.
            pass
            
        return b''
