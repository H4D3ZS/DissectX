"""
Advanced Vulnerability Scanner for DissectX Auto-Exploiter

Detects multiple vulnerability types:
- Format string vulnerabilities
- Heap vulnerabilities (UAF, double-free, heap overflow)
- Integer overflows/underflows
- Use-after-free
"""

from typing import List, Optional, Dict, Set
from dataclasses import dataclass
from enum import Enum
import re


class VulnType(Enum):
    """Types of vulnerabilities that can be detected"""
    BUFFER_OVERFLOW = "buffer_overflow"
    FORMAT_STRING = "format_string"
    HEAP_OVERFLOW = "heap_overflow"
    USE_AFTER_FREE = "use_after_free"
    DOUBLE_FREE = "double_free"
    INTEGER_OVERFLOW = "integer_overflow"
    INTEGER_UNDERFLOW = "integer_underflow"


@dataclass
class Vulnerability:
    """Represents a detected vulnerability"""
    vuln_type: VulnType
    function_name: str
    address: int
    severity: str  # 'critical', 'high', 'medium', 'low'
    description: str
    exploitable: bool
    confidence: float  # 0.0 to 1.0
    metadata: Dict = None


class VulnerabilityScanner:
    """
    Advanced vulnerability detection engine
    """
    
    def __init__(self, binary_path: str):
        self.binary_path = binary_path
        self.vulnerabilities: List[Vulnerability] = []
        
        # Dangerous functions that can lead to vulnerabilities
        self.format_string_funcs = {'printf', 'sprintf', 'fprintf', 'snprintf', 'vprintf', 'vsprintf'}
        self.heap_funcs = {'malloc', 'free', 'realloc', 'calloc'}
        self.unsafe_funcs = {'gets', 'strcpy', 'strcat', 'scanf', 'vscanf'}
        
    def scan_all(self) -> List[Vulnerability]:
        """
        Run all vulnerability detection methods
        
        Returns:
            List of detected vulnerabilities
        """
        from pwn import ELF
        
        try:
            elf = ELF(self.binary_path, checksec=False)
            
            # Detect different vulnerability types
            self._detect_format_string(elf)
            self._detect_heap_vulnerabilities(elf)
            self._detect_integer_issues(elf)
            self._detect_buffer_overflows(elf)
            
            # Sort by severity
            severity_order = {'critical': 0, 'high': 1, 'medium': 2, 'low': 3}
            self.vulnerabilities.sort(key=lambda v: severity_order.get(v.severity, 4))
            
            return self.vulnerabilities
            
        except Exception as e:
            print(f"[-] Vulnerability scan error: {e}")
            return []
    
    def _detect_format_string(self, elf) -> None:
        """
        Detect format string vulnerabilities
        
        Looks for:
        - printf/sprintf calls with user-controlled format strings
        - Missing format specifiers
        """
        try:
            # Check PLT for format string functions
            for func_name in self.format_string_funcs:
                if func_name in elf.plt:
                    # Found a format string function
                    vuln = Vulnerability(
                        vuln_type=VulnType.FORMAT_STRING,
                        function_name=func_name,
                        address=elf.plt[func_name],
                        severity='high',
                        description=f"Potential format string vulnerability in {func_name}",
                        exploitable=True,
                        confidence=0.7,
                        metadata={'function': func_name, 'plt_address': hex(elf.plt[func_name])}
                    )
                    self.vulnerabilities.append(vuln)
                    print(f"[+] Detected potential format string vuln: {func_name} at {hex(elf.plt[func_name])}")
                    
        except Exception as e:
            print(f"[-] Format string detection error: {e}")
    
    def _detect_heap_vulnerabilities(self, elf) -> None:
        """
        Detect heap-related vulnerabilities
        
        Looks for:
        - Use-after-free patterns
        - Double-free possibilities
        - Heap overflow opportunities
        """
        try:
            has_malloc = 'malloc' in elf.plt or 'malloc' in elf.symbols
            has_free = 'free' in elf.plt or 'free' in elf.symbols
            
            if has_malloc and has_free:
                # Potential for heap vulnerabilities
                vuln = Vulnerability(
                    vuln_type=VulnType.HEAP_OVERFLOW,
                    function_name='heap_operations',
                    address=elf.plt.get('malloc', 0) or elf.symbols.get('malloc', 0),
                    severity='high',
                    description="Binary uses heap allocation - potential for heap vulnerabilities",
                    exploitable=True,
                    confidence=0.6,
                    metadata={'has_malloc': has_malloc, 'has_free': has_free}
                )
                self.vulnerabilities.append(vuln)
                print(f"[+] Detected heap operations - potential vulnerabilities")
                
        except Exception as e:
            print(f"[-] Heap vulnerability detection error: {e}")
    
    def _detect_integer_issues(self, elf) -> None:
        """
        Detect integer overflow/underflow vulnerabilities
        
        Looks for:
        - Arithmetic operations without bounds checking
        - Size calculations that could overflow
        """
        try:
            # Check for functions that commonly have integer issues
            risky_funcs = {'read', 'recv', 'fread'}
            
            for func in risky_funcs:
                if func in elf.plt or func in elf.symbols:
                    vuln = Vulnerability(
                        vuln_type=VulnType.INTEGER_OVERFLOW,
                        function_name=func,
                        address=elf.plt.get(func, 0) or elf.symbols.get(func, 0),
                        severity='medium',
                        description=f"Function {func} may be vulnerable to integer overflow in size calculations",
                        exploitable=True,
                        confidence=0.5,
                        metadata={'function': func}
                    )
                    self.vulnerabilities.append(vuln)
                    
        except Exception as e:
            print(f"[-] Integer issue detection error: {e}")
    
    def _detect_buffer_overflows(self, elf) -> None:
        """
        Detect classic buffer overflow vulnerabilities
        
        Looks for:
        - Unsafe string functions (gets, strcpy, etc.)
        - Unbounded reads
        """
        try:
            for func in self.unsafe_funcs:
                if func in elf.plt or func in elf.symbols:
                    vuln = Vulnerability(
                        vuln_type=VulnType.BUFFER_OVERFLOW,
                        function_name=func,
                        address=elf.plt.get(func, 0) or elf.symbols.get(func, 0),
                        severity='critical',
                        description=f"Unsafe function {func} detected - classic buffer overflow",
                        exploitable=True,
                        confidence=0.9,
                        metadata={'function': func}
                    )
                    self.vulnerabilities.append(vuln)
                    print(f"[+] Detected unsafe function: {func}")
                    
        except Exception as e:
            print(f"[-] Buffer overflow detection error: {e}")
    
    def get_exploitable_vulns(self) -> List[Vulnerability]:
        """Get only exploitable vulnerabilities"""
        return [v for v in self.vulnerabilities if v.exploitable]
    
    def get_by_type(self, vuln_type: VulnType) -> List[Vulnerability]:
        """Get vulnerabilities of a specific type"""
        return [v for v in self.vulnerabilities if v.vuln_type == vuln_type]
    
    def get_highest_severity(self) -> Optional[Vulnerability]:
        """Get the most severe vulnerability"""
        if not self.vulnerabilities:
            return None
        return self.vulnerabilities[0]  # Already sorted by severity
