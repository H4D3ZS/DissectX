import subprocess
from typing import List, Dict, Optional

class VulnerabilityDetector:
    """
    Detects potential vulnerabilities in binary files.
    Scans for dangerous functions and insecure coding patterns.
    """

    def __init__(self):
        self.dangerous_functions = {
            'gets': 'Buffer Overflow (No bounds checking)',
            'strcpy': 'Buffer Overflow (No bounds checking)',
            'strcat': 'Buffer Overflow (No bounds checking)',
            'sprintf': 'Buffer Overflow (No bounds checking)',
            'vsprintf': 'Buffer Overflow (No bounds checking)',
            'system': 'Command Injection',
            'popen': 'Command Injection',
            'exec': 'Command Injection',
            'execl': 'Command Injection',
            'execle': 'Command Injection',
            'execlp': 'Command Injection',
            'execv': 'Command Injection',
            'execve': 'Command Injection',
            'execvp': 'Command Injection',
            'execvpe': 'Command Injection',
            'printf': 'Format String Vulnerability (if user input is format string)',
            'fprintf': 'Format String Vulnerability (if user input is format string)',
            'dprintf': 'Format String Vulnerability (if user input is format string)',
        }

    def scan(self, filepath: str) -> List[Dict[str, str]]:
        """
        Scan the binary for known dangerous functions.
        
        Args:
            filepath: Path to the binary file
            
        Returns:
            List of detected vulnerabilities
        """
        vulnerabilities = []
        
        # Get imported symbols using nm
        imported_symbols = self._get_imported_symbols(filepath)
        
        for symbol in imported_symbols:
            # Remove version info (e.g., gets@GLIBC_2.2.5 -> gets)
            clean_symbol = symbol.split('@')[0]
            
            if clean_symbol in self.dangerous_functions:
                vulnerabilities.append({
                    'function': clean_symbol,
                    'risk': self.dangerous_functions[clean_symbol],
                    'location': 'Imported Symbol' # We don't know exact call site without disassembly here
                })
                
        return vulnerabilities

    def _get_imported_symbols(self, filepath: str) -> List[str]:
        """
        Get list of imported symbols using nm or objdump.
        """
        symbols = []
        try:
            # Try nm -u (undefined/imported symbols)
            result = subprocess.run(
                ['nm', '-u', filepath],
                capture_output=True,
                text=True,
                timeout=5
            )
            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    # nm output: "                 U gets"
                    parts = line.strip().split()
                    if len(parts) >= 2 and parts[0] == 'U':
                        symbols.append(parts[1])
                    elif len(parts) == 1 and line.strip(): # sometimes just the name
                         symbols.append(line.strip())
            else:
                # Fallback to objdump -T (dynamic symbols)
                result = subprocess.run(
                    ['objdump', '-T', filepath],
                    capture_output=True,
                    text=True,
                    timeout=5
                )
                if result.returncode == 0:
                    for line in result.stdout.split('\n'):
                        # 0000000000000000      DF *UND*  0000000000000000  GLIBC_2.2.5 gets
                        if '*UND*' in line:
                            parts = line.split()
                            if len(parts) > 0:
                                symbols.append(parts[-1])

        except (subprocess.TimeoutExpired, FileNotFoundError, subprocess.SubprocessError):
            pass
            
        return symbols
